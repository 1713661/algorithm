import sys
from collections import deque
input = sys.stdin.readline

# 한칸 가는거랑 끝까지 가는 거 구현해야하나? Yes

# [Ctrl] 키를 누른 상태에서 방향키 ←, ↑, ↓, → 중 하나를 누르면, 
# 누른 키 방향에 있는 가장 가까운 카드로 한번에 이동합니다.
# 만약, 해당 방향에 카드가 하나도 없다면 그 방향의 가장 마지막 칸으로 이동합니다.

##### [Enter] 키를 입력 ##### 이것도 cnt 하나 추가
# 앞면이 보이는 카드가 1장 뿐이라면 그림을 맞출 수 없으므로 
# 두번째 카드를 뒤집을 때 까지 앞면을 유지합니다.

# 앞면이 보이는 카드가 2장이 된 경우, 
# 두개의 카드에 그려진 그림이 같으면 해당 카드들이 화면에서 사라지며, <---- 0으로 구현
# 그림이 다르다면 두 카드 모두 뒷면이 보이도록 다시 뒤집힙니다.

# 키 조작 횟수의 최솟값을 return 

# 16분 템플릿 대강 짬
# 24분 ctrl 어떻게 구현할지
# 38분 ctrl 따로 구현할 필요없이 for문에서 끝까지 간 4개좌표 추가하면 됨(하... 왜이렇게생각했을까. 이것땜에 시간버림)
# 47분 ########누른 키 방향에 있는 '''가장 가까운 카드'''로 한번에 이동합니다. ctrl 구현해야함(아... 조건 제대로 안봄)
# 만약, 누른 키 방향으로 이동 가능한 카드 또는 빈 공간이 없어 이동할 수 없다면 커서는 움직이지 않습니다.
# + 14분 문제 다시 읽어봤는데 100프로 이해안됨.. (지금 머리 안돌아가는듯)
# + 12분 문제 또 다시 읽어봄(나에게는 너무 어려운 문제)

##### 같은 그림이 아니라면 원래 상태로 뒷면이 보이도록 뒤집힙니다.
##### 이때 cnt += 1 하는건지?


##### 없앨 카드의 순서 왜 정해야 하는지 모르겠음...

########## 나는 이 '뒤집힌다'는 거 그대로 구현할 생각이었는데 순열 쓰면 되잖아!!!!!!!!!!!!!
########## (나는 지금 A 카드 찾고 있으니 탐색 도중 B 카드 나오면 그냥 넘어갈거야.. 이런식으로)


from collections import deque

def solution(board, r, c): # 처음 위치 r, c
    '''
    dx = [0,0,1,-1] # 동서남북
    dy = [1,-1,0,0]
    '''
    N = len(board)
    answer = []
    q = deque()
    q.append((r,c,0))

    def ctrl(x,y,nx,ny):
        dx,dy = nx-x,ny-y #동서남북 #(0,1),(0,-1),(1,0),(-1,0)
        while 0<=nx+dx<N and 0<=ny+dy<N and board[nx+dx][ny+dy]==0:
            nx += dx
            ny += dy
        return nx,ny

    

    while q: #for _ in range(10): #
        x,y,cnt = q.popleft()
        #print("now=",x,y,"cnt=",cnt)

        if sum(map(sum,board))==0: #######연산량 너무 많나? 아냐 4X4니까 괜춘
            return cnt
        
        ##### [Enter] 키를 입력 ##### 이것도 cnt 하나 추가
        # 앞면이 보이는 카드가 1장 뿐이라면 그림을 맞출 수 없으므로 
        # 두번째 카드를 뒤집을 때 까지 앞면을 유지합니다.
        # 47분 ########누른 키 방향에 있는 가장 가까운 카드로 한번에 이동합니다.(아... 조건 제대로 안봄)
        # 만약, 누른 키 방향으로 이동 가능한 카드 또는 빈 공간이 없어 이동할 수 없다면 커서는 움직이지 않습니다.
        ############### 커서 옮겨서 카드 나왔을 때 enter칠거냐 말거냐에 따라 dp만들어야하는듯
        for (nx,ny) in (x,y+1),(x,y-1),(x+1,y),(x-1,y):#, (r,3),(r,0),(3,c),(0,c): #######동서남북 #(0,1),(0,-1),(1,0),(-1,0)
            if 0<=nx<N and 0<=ny<N:
                if board[nx][ny]!=0:
                    if board[nx][ny]==board[x][y]: # 두개의 카드에 그려진 그림이 같으면 해당 카드들이 화면에서 사라지며,
                        board[x][y]=0
                        board[nx][ny]=0
                        q.append((nx,ny,cnt+2)) #화살표+엔터
                    else:                          # board[nr][nc]!=board[r][c] 그림이 다르다면 두 카드 ''''모두 뒷면이 보이도록'''' (이거어떻게구현해야하지?) 다시 뒤집힙니다.
                        q.append((nx,ny,cnt+1))
                '''
                else: #board[nr][nc]==0 ctrl+화살표 실행
                    nx,ny = ctrl(x,y,nx,ny)
                    q.append((nx,ny,cnt+2)) 
                '''

                # 누른 키 방향에 있는 가장 가까운 카드로 한번에 이동합니다.
                '''
                if board[nr][nc]==board[r][c]: # 두개의 카드에 그려진 그림이 같으면 해당 카드들이 화면에서 사라지며,
                        board[r][c]=0
                        board[nr][nc]=0
                        q.append((nr,nc,cnt+1))
                else:                          # board[nr][nc]!=board[r][c] 그림이 다르다면 두 카드 ''''모두 뒷면이 보이도록'''' (이거어떻게구현해야하지?) 다시 뒤집힙니다.
                    q.append((nr,nc,cnt+1))
                '''



    print(answer)
    return min(answer)


print(solution([[1,0,0,3],[2,0,0,0],[0,0,0,2],[3,0,1,0]],1,0)) # 14