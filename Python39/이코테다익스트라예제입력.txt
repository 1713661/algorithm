###### 내가 구한 방법은 최단 경로가 여러 가지인 경우를 구현하기 어려움! 
(elif cost==dist[i[0] 이거는 맞는 방법 아님!!!!!)


#이코테 그래프 예제(이건 노드 1부터 시작하기 때문에 index error 남!)
6 11
1 6
1 2 2
1 4 1
1 3 5
2 3 3
2 4 2
3 2 3
3 6 5
4 3 3
4 5 1
5 3 1
5 6 2
0 0

# 1504에 맞게 입력바꾸기
6 11
1 2 2
1 4 1
1 3 5
2 3 3
2 4 2
3 2 3
3 6 5
4 3 3
4 5 1
5 3 1
5 6 2
2 3

출력
[10000000000, 0, 2, 3, 1, 2, 4]


#2->3 weight 1로 바꿔 줄 경우 1->3 최단경로 2개됨
6 11
1 6
1 2 2
1 4 1
1 3 5
2 3 1
2 4 2
3 2 3
3 6 5
4 3 3
4 5 1
5 3 1
5 6 2
0 0

#노드값 0번부터 시작하는 걸로 바꾼 입력값
6 11
0 5
0 1 2
0 3 1
0 2 5
1 2 3
1 3 2
2 1 3
2 5 5
3 2 3
3 4 1
4 2 1
4 5 2
0 0

graph= [[], [(2, 2), (4, 1), (3, 5)], [(3, 3), (4, 2)], [(2, 3), (6, 5)], [(3, 3), (5, 1)], [(3, 1), (6, 2)], []]
paths= [[1], [1], [1, 2], [1, 4, 5, 3], [1, 4], [1, 4, 5], [1, 4, 5, 6]]
delTuples= [(1, 2), (1, 4), (4, 5), (5, 3), (1, 4), (1, 4), (4, 5), (1, 4), (4, 5), (5, 6)]

# 이렇게 튜플 형태로 저장하는 건 튜플의 원소 추출해서 각각의 변수에 할당해줄 때 좋은 것 같고,
u,v 값으로 접근해야 할 때는 딕셔너리 써야할 것 같다. (자료형 공부 다시!!!!) 
[리스트{딕셔너리}](2차원) 그냥 리스트처럼 중괄호 [a][b]<- 이렇게 써주면 되던데 6/24(목)에는 왜 자꾸 오류났는지 모르겠다
dict()으로 초기화 안하고 {}이렇게 해서? 파이썬 문법책에서는 중괄호로 초기화해도 된다고 하던데 리스트까지 하면 2차원이라서 그런가??
<[리스트{딕셔너리}] 입력>
graph = [dict() for _ in range(n)]
for _ in range(m):
            u, v, p = map(int, sys.stdin.readline().split())  # 도로 정보 입력
            graph[u][v] = p	#############"u번째 리스트"에 "key=v" value=p인 딕셔너리 원소 넣기???
	u->리스트 v->딕셔너리
**************** 딕셔너리도 리스트처럼 dict[a]=b꼴로 원소 추가함(리스트는 list[a]=b 이런식으로 원소 추가하는 건 안되고 변경만 가능하지만.. 형태가 똑같다는 말이었음!)
<[리스트{딕셔너리}] 출력>
graph= [{1: 1, 2: 1, 3: 2, 4: 3}, {5: 2}, {6: 4}, {6: 2}, {6: 4}, {6: 1}, {}]
graph= [{1: 1}, {2: 1, 3: 1}, {0: 3}, {2: 1, 0: 2}]
graph= [{1: 1, 2: 2, 3: 3}, {}, {5: 3}, {4: 2, 0: 1}, {1: 1}, {1: 1}]


#### elif cost==dist[i[0]]:은 맞는 방법이 아닌 것 같다! cost와 dist[i[0]]이 같다는 게 
그 경로가 '최단 경로'랑 같다는 게 아니라 테이블에 있는 값, 즉 "최단 경로가 아닐 수도 있는 값"이기 때문에
####사람들이 많이 쓴 역추적 방법 쓰는 게 좋을 것 같다!(내가 쓴 방법인 '다익스트라 함수에서 배열 만들기'는 좋은 방법이 아닌 것 같다)



################블로그 풀이 글
다익스트라 문제이다. 하지만 기존의 다익스트라와 달리, 최단경로를 찾아서 최적경로의 간선을 제거해줘야한다.

처음에, 최적경로 하나마다 삭제를 했더니, 최적경로의 간선은 다른 최적경로에서 사용을 할 수 있기 때문에 틀렸다고 나왔다 

두번째로는 시간초과의 늪에 많이 빠졌다. 

처음에는 최적의 경로를 min_distance가 갱신될때마다 저장을 시켜놨더니 시간이 초과가 되었다.

그래서 다음과 같은 로직으로 최적의 경로쌍을 찾았다

도착지점의 distance의 값을 distance[end]라 하겠다.

distance[prev_node] + graph[prev_node][end] == distance[end]을 만족하는 prev_node는 prev_node에서 end node로 오는 최단경로임을 알수 있다.

이 (prev_node,end) 쌍을 지울 집합에 추가해주고, prev_node를 stack에 넣어준다.

이 과정을 반복하면, 끝점에서부터 최단경로로 오는 간선들을 전부 찾을 수 있다.

그리고 난뒤 해당 간선들을 지우는 과정을 하면 된다.

그리고 마지막으로 다익스트라를 한번 더 한뒤 결과에 맞게 출력해주면 된다.

다익스트라는 자주 쓰지 않던 알고리즘이라 푸는데 어려웠고, 기본적으로 다익스트라는 최단경로의 길이를 출력해주는 것이기 때문에, 최단경로의 경로를 이용하기 위해서 다익스트라 과정에서 나온 결과물을 이용해야한다는 점을 배웠다.




#2->3 weight 1로 바꿔 줄 경우 1->3 최단경로 2개됨
6 11
1 6
1 2 2
1 4 1
1 3 5
2 3 1
2 4 2
3 2 3
3 6 5
4 3 3
4 5 1
5 3 1
5 6 2
0 0

'''
def delPath(graph,paths):
    for path in paths:
        l = int(len(path))
        if l<=1:
            continue
        for i in range(l):
            u=path[i]
            v=path[i+1]1
            print(u,v)
'''    
